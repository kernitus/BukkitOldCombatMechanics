/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package kernitus.plugin.OldCombatMechanics

import com.cryptomorin.xseries.XAttribute
import com.cryptomorin.xseries.XMaterial
import com.cryptomorin.xseries.XPotion
import io.kotest.common.ExperimentalKotest
import io.kotest.core.spec.style.FunSpec
import io.kotest.matchers.ints.shouldBeExactly
import io.kotest.matchers.shouldBe
import kernitus.plugin.OldCombatMechanics.utilities.damage.NewWeaponDamage
import org.bukkit.Bukkit
import org.bukkit.GameMode
import org.bukkit.Location
import org.bukkit.Material
import org.bukkit.attribute.AttributeModifier
import org.bukkit.entity.LivingEntity
import org.bukkit.entity.Player
import org.bukkit.event.EventHandler
import org.bukkit.event.HandlerList
import org.bukkit.event.Listener
import org.bukkit.event.entity.EntityDamageByEntityEvent
import org.bukkit.event.player.PlayerItemConsumeEvent
import org.bukkit.inventory.EquipmentSlot
import org.bukkit.inventory.ItemStack
import org.bukkit.inventory.meta.PotionMeta
import org.bukkit.plugin.java.JavaPlugin
import org.bukkit.potion.PotionData
import org.bukkit.potion.PotionEffect
import org.bukkit.potion.PotionEffectType
import org.bukkit.potion.PotionType
import kotlinx.coroutines.delay
import java.util.concurrent.Callable
import kernitus.plugin.OldCombatMechanics.utilities.storage.PlayerStorage.getPlayerData
import kernitus.plugin.OldCombatMechanics.utilities.storage.PlayerStorage.setPlayerData
import kotlin.math.abs

@OptIn(ExperimentalKotest::class)
class InvulnerabilityDamageIntegrationTest : FunSpec({
    val plugin = JavaPlugin.getPlugin(OCMTestMain::class.java)
    extensions(MainThreadDispatcherExtension(plugin))

    fun runSync(action: () -> Unit) {
        if (Bukkit.isPrimaryThread()) {
            action()
        } else {
            Bukkit.getScheduler().callSyncMethod(plugin, Callable {
                action()
                null
            }).get()
        }
    }

    suspend fun delayTicks(ticks: Long) {
        delay(ticks * 50L)
    }

    fun prepareWeapon(item: ItemStack) {
        val meta = item.itemMeta ?: return
        val speedModifier = createAttributeModifier(
            name = "speed",
            amount = 1000.0,
            operation = AttributeModifier.Operation.ADD_NUMBER,
            slot = EquipmentSlot.HAND
        )
        val attackSpeedAttribute = XAttribute.ATTACK_SPEED.get() ?: return
        addAttributeModifierCompat(meta, attackSpeedAttribute, speedModifier)
        item.itemMeta = meta
    }

    fun applyAttackDamageModifiers(player: Player, item: ItemStack) {
        val attackDamageAttribute = XAttribute.ATTACK_DAMAGE.get() ?: return
        val attackAttribute = player.getAttribute(attackDamageAttribute) ?: return
        val modifiers = getDefaultAttributeModifiersCompat(item, EquipmentSlot.HAND, attackDamageAttribute)
        val expectedAmounts = modifiers
            .filter { it.operation == AttributeModifier.Operation.ADD_NUMBER }
            .map { it.amount }
        val knownWeaponAmounts = NewWeaponDamage.values()
            .map { it.damage.toDouble() - 1.0 }
            .filter { it > 0.0 }
            .toSet()

        fun matchesAmount(first: Double, second: Double): Boolean = abs(first - second) <= 0.0001

        val existingModifiers = attackAttribute.modifiers.toList()
        existingModifiers
            .filter { it.operation == AttributeModifier.Operation.ADD_NUMBER && it.amount > 0.0 }
            .filter { modifier ->
                knownWeaponAmounts.any { matchesAmount(it, modifier.amount) } &&
                    expectedAmounts.none { expected -> matchesAmount(expected, modifier.amount) }
            }
            .forEach { attackAttribute.removeModifier(it) }

        modifiers.forEach { modifier ->
            val alreadyApplied = attackAttribute.modifiers.any {
                it.operation == modifier.operation && matchesAmount(it.amount, modifier.amount)
            }
            if (!alreadyApplied) {
                attackAttribute.addModifier(modifier)
            }
        }
    }

    fun equip(player: Player, item: ItemStack) {
        prepareWeapon(item)
        player.inventory.setItemInMainHand(item)
        applyAttackDamageModifiers(player, item)
        player.updateInventory()
    }

    fun spawnAttacker(location: Location): Pair<FakePlayer, Player> {
        val fake = FakePlayer(plugin)
        fake.spawn(location)
        val player = checkNotNull(Bukkit.getPlayer(fake.uuid))
        player.gameMode = GameMode.SURVIVAL
        player.isInvulnerable = false
        player.inventory.clear()
        player.activePotionEffects.forEach { player.removePotionEffect(it.type) }
        val playerData = getPlayerData(player.uniqueId)
        playerData.setModesetForWorld(player.world.uid, "old")
        setPlayerData(player.uniqueId, playerData)
        return fake to player
    }

    fun spawnVictim(location: Location): LivingEntity {
        val world = location.world ?: error("World missing for victim spawn")
        return world.spawn(location, org.bukkit.entity.Cow::class.java).apply {
            maximumNoDamageTicks = 20
            noDamageTicks = 0
            isInvulnerable = false
            health = maxHealth
        }
    }

    fun createWeaknessPotion(): ItemStack {
        val item = ItemStack(Material.POTION)
        val meta = item.itemMeta as PotionMeta
        try {
            meta.basePotionType = PotionType.WEAKNESS
        } catch (e: NoSuchMethodError) {
            @Suppress("DEPRECATION") // Required for legacy server compatibility.
            meta.basePotionData = PotionData(PotionType.WEAKNESS, false, false)
        }
        item.itemMeta = meta
        return item
    }

    fun consumeWeaknessPotion(player: Player): PotionEffect {
        val item = createWeaknessPotion()
        val ctor = PlayerItemConsumeEvent::class.java.constructors.firstOrNull { constructor ->
            val params = constructor.parameterTypes
            params.size == 3 &&
                Player::class.java.isAssignableFrom(params[0]) &&
                ItemStack::class.java.isAssignableFrom(params[1]) &&
                EquipmentSlot::class.java.isAssignableFrom(params[2])
        }
        val event = if (ctor != null) {
            ctor.newInstance(player, item, EquipmentSlot.HAND) as PlayerItemConsumeEvent
        } else {
            PlayerItemConsumeEvent(player, item)
        }
        Bukkit.getPluginManager().callEvent(event)
        val meta = event.item.itemMeta as PotionMeta
        return meta.customEffects.firstOrNull { it.type == PotionEffectType.WEAKNESS }
            ?: error("Weakness effect missing from potion meta")
    }

    test("second hit in the same tick should still fire inside invulnerability").config(
        enabled = false
    ) {
        // Disabled: current vanilla pipeline drops same-tick follow-up hits during invulnerability.
        // We will revisit once the intended behaviour is defined across versions.
        val events = mutableListOf<EntityDamageByEntityEvent>()
        lateinit var attacker1: Player
        lateinit var attacker2: Player
        var victim: LivingEntity? = null
        var fake1: FakePlayer? = null
        var fake2: FakePlayer? = null

        val listener = object : Listener {
            @EventHandler
            fun onDamage(event: EntityDamageByEntityEvent) {
                val currentVictim = victim ?: return
                if (event.entity.uniqueId == currentVictim.uniqueId &&
                    (event.damager.uniqueId == attacker1.uniqueId || event.damager.uniqueId == attacker2.uniqueId)
                ) {
                    events.add(event)
                }
            }
        }

        try {
            runSync {
                val world = checkNotNull(Bukkit.getWorld("world"))
                val attacker1Location = Location(world, 0.0, 100.0, 0.0)
                val attacker2Location = Location(world, 0.0, 100.0, 2.0)
                val victimLocation = Location(world, 1.2, 100.0, 0.0)

                val (fakeA, playerA) = spawnAttacker(attacker1Location)
                val (fakeB, playerB) = spawnAttacker(attacker2Location)
                fake1 = fakeA
                fake2 = fakeB
                attacker1 = playerA
                attacker2 = playerB
                val spawnedVictim = spawnVictim(victimLocation)
                victim = spawnedVictim

                Bukkit.getPluginManager().registerEvents(listener, plugin)

                equip(attacker1, ItemStack(Material.DIAMOND_SWORD))
                equip(attacker2, ItemStack(Material.STONE_SWORD))

                attackCompat(attacker1, spawnedVictim)
                attackCompat(attacker2, spawnedVictim)
                val attackDamageAttribute = XAttribute.ATTACK_DAMAGE.get()
                val attacker1Damage = attackDamageAttribute?.let { attacker1.getAttribute(it)?.value }
                val attacker2Damage = attackDamageAttribute?.let { attacker2.getAttribute(it)?.value }
                plugin.logger.info(
                    "Invuln same-tick debug: events=${events.size} " +
                        "noDamageTicks=${spawnedVictim.noDamageTicks} lastDamage=${spawnedVictim.lastDamage} " +
                        "attacker1Damage=$attacker1Damage attacker2Damage=$attacker2Damage"
                )
            }
            delayTicks(3)
            runSync {
                val currentVictim = checkNotNull(victim)
                plugin.logger.info(
                    "Invuln same-tick debug (post): events=${events.size} " +
                        "noDamageTicks=${currentVictim.noDamageTicks} lastDamage=${currentVictim.lastDamage} " +
                        "lastEventDamage=${events.lastOrNull()?.damage} lastEventFinal=${events.lastOrNull()?.finalDamage}"
                )
            }
            events.size.shouldBeExactly(2)
        } finally {
            HandlerList.unregisterAll(listener)
            runSync {
                fake1?.removePlayer()
                fake2?.removePlayer()
                victim?.remove()
            }
        }
    }

    test("slightly higher base damage inside invulnerability should fire") {
        val events = mutableListOf<EntityDamageByEntityEvent>()
        lateinit var attacker: Player
        var victim: LivingEntity? = null
        var fake: FakePlayer? = null

        val listener = object : Listener {
            @EventHandler
            fun onDamage(event: EntityDamageByEntityEvent) {
                val currentVictim = victim ?: return
                if (event.entity.uniqueId == currentVictim.uniqueId &&
                    event.damager.uniqueId == attacker.uniqueId
                ) {
                    events.add(event)
                }
            }
        }

        try {
            runSync {
                val world = checkNotNull(Bukkit.getWorld("world"))
                val attackerLocation = Location(world, 0.0, 100.0, 0.0)
                val victimLocation = Location(world, 1.2, 100.0, 0.0)

                val (fakeA, playerA) = spawnAttacker(attackerLocation)
                fake = fakeA
                attacker = playerA
                val spawnedVictim = spawnVictim(victimLocation)
                victim = spawnedVictim

                Bukkit.getPluginManager().registerEvents(listener, plugin)

                val woodenSword = XMaterial.WOODEN_SWORD.parseItem()
                    ?: error("WOODEN_SWORD material not available")
                equip(attacker, woodenSword)
                attackCompat(attacker, spawnedVictim)
                val attackDamageAttribute = XAttribute.ATTACK_DAMAGE.get()
                val attackerDamage = attackDamageAttribute?.let { attacker.getAttribute(it)?.value }
                plugin.logger.info(
                    "Invuln overdamage debug (first hit): events=${events.size} " +
                        "noDamageTicks=${spawnedVictim.noDamageTicks} lastDamage=${spawnedVictim.lastDamage} " +
                        "attackerDamage=$attackerDamage"
                )
            }

            delayTicks(2)

            runSync {
                val currentVictim = checkNotNull(victim)
                val firstDamage = events.firstOrNull()?.damage
                    ?: error("Expected a damage event from the first hit")
                currentVictim.noDamageTicks = currentVictim.maximumNoDamageTicks
                currentVictim.lastDamage = firstDamage

                val stoneSword = XMaterial.STONE_SWORD.parseItem()
                    ?: error("STONE_SWORD material not available")
                equip(attacker, stoneSword)
                attackCompat(attacker, currentVictim)
                val attackDamageAttribute = XAttribute.ATTACK_DAMAGE.get()
                val attackerDamage = attackDamageAttribute?.let { attacker.getAttribute(it)?.value }
                plugin.logger.info(
                    "Invuln overdamage debug (second hit): events=${events.size} " +
                        "noDamageTicks=${currentVictim.noDamageTicks} lastDamage=${currentVictim.lastDamage} " +
                        "attackerDamage=$attackerDamage firstDamage=$firstDamage"
                )
            }

            delayTicks(2)
            runSync {
                val currentVictim = checkNotNull(victim)
                plugin.logger.info(
                    "Invuln overdamage debug (post): events=${events.size} " +
                        "noDamageTicks=${currentVictim.noDamageTicks} lastDamage=${currentVictim.lastDamage} " +
                        "lastEventDamage=${events.lastOrNull()?.damage} lastEventFinal=${events.lastOrNull()?.finalDamage}"
                )
            }
            events.size.shouldBeExactly(2)
        } finally {
            HandlerList.unregisterAll(listener)
            runSync {
                fake?.removePlayer()
                victim?.remove()
            }
        }
    }

    test("clearly higher base damage inside invulnerability should fire") {
        val events = mutableListOf<EntityDamageByEntityEvent>()
        lateinit var attacker: Player
        var victim: LivingEntity? = null
        var fake: FakePlayer? = null

        val listener = object : Listener {
            @EventHandler
            fun onDamage(event: EntityDamageByEntityEvent) {
                val currentVictim = victim ?: return
                if (event.entity.uniqueId == currentVictim.uniqueId &&
                    event.damager.uniqueId == attacker.uniqueId
                ) {
                    events.add(event)
                }
            }
        }

        try {
            runSync {
                val world = checkNotNull(Bukkit.getWorld("world"))
                val attackerLocation = Location(world, 0.0, 100.0, 0.0)
                val victimLocation = Location(world, 1.2, 100.0, 0.0)

                val (fakeA, playerA) = spawnAttacker(attackerLocation)
                fake = fakeA
                attacker = playerA
                val spawnedVictim = spawnVictim(victimLocation)
                victim = spawnedVictim

                Bukkit.getPluginManager().registerEvents(listener, plugin)

                val woodenSword = XMaterial.WOODEN_SWORD.parseItem()
                    ?: error("WOODEN_SWORD material not available")
                equip(attacker, woodenSword)
                attackCompat(attacker, spawnedVictim)
                val attackDamageAttribute = XAttribute.ATTACK_DAMAGE.get()
                val attackerDamage = attackDamageAttribute?.let { attacker.getAttribute(it)?.value }
                plugin.logger.info(
                    "Invuln overdamage (iron) debug (first hit): events=${events.size} " +
                        "noDamageTicks=${spawnedVictim.noDamageTicks} lastDamage=${spawnedVictim.lastDamage} " +
                        "attackerDamage=$attackerDamage"
                )
            }

            delayTicks(2)

            runSync {
                val currentVictim = checkNotNull(victim)
                val firstDamage = events.firstOrNull()?.damage
                    ?: error("Expected a damage event from the first hit")
                currentVictim.noDamageTicks = currentVictim.maximumNoDamageTicks
                currentVictim.lastDamage = firstDamage

                val ironSword = XMaterial.IRON_SWORD.parseItem()
                    ?: error("IRON_SWORD material not available")
                equip(attacker, ironSword)
                attackCompat(attacker, currentVictim)
                val attackDamageAttribute = XAttribute.ATTACK_DAMAGE.get()
                val attackerDamage = attackDamageAttribute?.let { attacker.getAttribute(it)?.value }
                plugin.logger.info(
                    "Invuln overdamage (iron) debug (second hit): events=${events.size} " +
                        "noDamageTicks=${currentVictim.noDamageTicks} lastDamage=${currentVictim.lastDamage} " +
                        "attackerDamage=$attackerDamage firstDamage=$firstDamage"
                )
            }

            delayTicks(2)
            runSync {
                val currentVictim = checkNotNull(victim)
                plugin.logger.info(
                    "Invuln overdamage (iron) debug (post): events=${events.size} " +
                        "noDamageTicks=${currentVictim.noDamageTicks} lastDamage=${currentVictim.lastDamage} " +
                        "lastEventDamage=${events.lastOrNull()?.damage} lastEventFinal=${events.lastOrNull()?.finalDamage}"
                )
            }
            events.size.shouldBeExactly(2)
        } finally {
            HandlerList.unregisterAll(listener)
            runSync {
                fake?.removePlayer()
                victim?.remove()
            }
        }
    }

    test("zero vanilla damage should still fire after lastDamage reset") {
        val events = mutableListOf<EntityDamageByEntityEvent>()
        lateinit var attacker: Player
        var victim: LivingEntity? = null
        var fake: FakePlayer? = null

        val listener = object : Listener {
            @EventHandler
            fun onDamage(event: EntityDamageByEntityEvent) {
                val currentVictim = victim ?: return
                if (event.entity.uniqueId == currentVictim.uniqueId &&
                    event.damager.uniqueId == attacker.uniqueId
                ) {
                    events.add(event)
                }
            }
        }

        try {
            runSync {
                val world = checkNotNull(Bukkit.getWorld("world"))
                val attackerLocation = Location(world, 0.0, 100.0, 0.0)
                val victimLocation = Location(world, 1.2, 100.0, 0.0)

                val (fakeA, playerA) = spawnAttacker(attackerLocation)
                fake = fakeA
                attacker = playerA
                val spawnedVictim = spawnVictim(victimLocation)
                victim = spawnedVictim

                Bukkit.getPluginManager().registerEvents(listener, plugin)

                equip(attacker, ItemStack(Material.DIAMOND_SWORD))
                attackCompat(attacker, spawnedVictim)
            }

            delayTicks(2) // allow MONITOR handler to set lastDamage to 0

            runSync {
                val currentVictim = checkNotNull(victim)
                currentVictim.noDamageTicks = currentVictim.maximumNoDamageTicks
                currentVictim.lastDamage.shouldBe(0.0)

                val effect = consumeWeaknessPotion(attacker)
                attacker.addPotionEffect(effect, true)
                val woodenSword = XMaterial.WOODEN_SWORD.parseItem() ?: ItemStack(Material.STONE_SWORD)
                equip(attacker, woodenSword)
                attackCompat(attacker, currentVictim)
            }

            delayTicks(3)
            events.size.shouldBeExactly(2)
        } finally {
            HandlerList.unregisterAll(listener)
            runSync {
                fake?.removePlayer()
                victim?.remove()
            }
        }
    }
})
